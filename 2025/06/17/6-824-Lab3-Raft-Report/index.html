<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"drlemonn.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="IntroductionIn this lab, you’ll need to implement Raft, a replicated state machine protocol.  基于Raft的论文，实现一个Go语言下的具备Raft功能的object，会在将来的实验中作为一个project的一个模块来使用。使用RPC通信来保持log的一致性。 Theory  论文中的Figure2基本涵盖">
<meta property="og:type" content="article">
<meta property="og:title" content="6.824 Lab3 Raft Report">
<meta property="og:url" content="https://drlemonn.github.io/2025/06/17/6-824-Lab3-Raft-Report/index.html">
<meta property="og:site_name" content="Lancey&#39;s Blogs">
<meta property="og:description" content="IntroductionIn this lab, you’ll need to implement Raft, a replicated state machine protocol.  基于Raft的论文，实现一个Go语言下的具备Raft功能的object，会在将来的实验中作为一个project的一个模块来使用。使用RPC通信来保持log的一致性。 Theory  论文中的Figure2基本涵盖">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://drlemonn.github.io/2025/06/17/6-824-Lab3-Raft-Report/image-20241126145450906.png">
<meta property="article:published_time" content="2025-06-17T08:30:40.000Z">
<meta property="article:modified_time" content="2025-06-17T08:55:38.116Z">
<meta property="article:author" content="Lancey">
<meta property="article:tag" content="coding, book-notes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://drlemonn.github.io/2025/06/17/6-824-Lab3-Raft-Report/image-20241126145450906.png">

<link rel="canonical" href="https://drlemonn.github.io/2025/06/17/6-824-Lab3-Raft-Report/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>6.824 Lab3 Raft Report | Lancey's Blogs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lancey's Blogs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Coding and Life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://drlemonn.github.io/2025/06/17/6-824-Lab3-Raft-Report/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Lancey">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lancey's Blogs">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6.824 Lab3 Raft Report
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-06-17 16:30:40 / Modified: 16:55:38" itemprop="dateCreated datePublished" datetime="2025-06-17T16:30:40+08:00">2025-06-17</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>In this lab, you’ll need to implement Raft, a replicated state machine protocol. </p>
<p>基于Raft的论文，实现一个Go语言下的具备Raft功能的object，会在将来的实验中作为一个project的一个模块来使用。使用RPC通信来保持log的一致性。</p>
<h1 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h1><img src="/2025/06/17/6-824-Lab3-Raft-Report/image-20241126145450906.png" class="">

<p>论文中的Figure2基本涵盖了所有Raft需要的实现细节。</p>
<p>Raft算法是基于<strong>Understandability</strong>来进行构造的。相较于以前的Paxos算法，更加地简洁易懂。</p>
<p>算法主要分为三个方面：Leader Election, Log Replication, Safety</p>
<h2 id="Leader-Election"><a href="#Leader-Election" class="headerlink" title="Leader Election"></a>Leader Election</h2><p>保证每一个Term都有且只有Leader被选出，并且其log is the most up-to-date。</p>
<h2 id="Log-Replication"><a href="#Log-Replication" class="headerlink" title="Log Replication"></a>Log Replication</h2><p>由Leader从client不断地接受command添加到log，将自身的Log由RPC发送给其他的peer，保证所有的log都是跟Leader一致。</p>
<h2 id="Safety"><a href="#Safety" class="headerlink" title="Safety"></a>Safety</h2><ul>
<li>Election Safety</li>
<li>Leader Append-Only</li>
<li>Log Matching</li>
<li>Leader Completeness</li>
<li>State Machine Safety</li>
</ul>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>涉及到的状态。在Figure2的基础上增添了一些。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu            sync.Mutex          <span class="comment">// Lock to protect shared access to this peer&#x27;s state</span></span><br><span class="line">	peers         []*labrpc.ClientEnd <span class="comment">// RPC end points of all peers</span></span><br><span class="line">	persister     *Persister          <span class="comment">// Object to hold this peer&#x27;s persisted state</span></span><br><span class="line">	me            <span class="type">int</span>                 <span class="comment">// this peer&#x27;s index into peers[]</span></span><br><span class="line">	dead          <span class="type">int32</span>               <span class="comment">// set by Kill()</span></span><br><span class="line">	applyCh       <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">	applyActive   <span class="type">bool</span></span><br><span class="line">	applySnapshot <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Your data here (3A, 3B, 3C).</span></span><br><span class="line">	<span class="comment">// Look at the paper&#x27;s Figure 2 for a description of what</span></span><br><span class="line">	<span class="comment">// state a Raft server must maintain.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Persistent state on all servers</span></span><br><span class="line">	currentTerm       <span class="type">int</span></span><br><span class="line">	votedFor          <span class="type">int</span></span><br><span class="line">	log               []LogEntry</span><br><span class="line">	snapshot          []<span class="type">byte</span></span><br><span class="line">	lastIncludedIndex <span class="type">int</span></span><br><span class="line">	lastIncludedTerm  <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Volatile state on all servers</span></span><br><span class="line">	commitIndex <span class="type">int</span></span><br><span class="line">	lastApplied <span class="type">int</span></span><br><span class="line">	raftState   RaftState</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Volatile state on leader</span></span><br><span class="line">	nextIndex  []<span class="type">int</span></span><br><span class="line">	matchIndex []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//added states</span></span><br><span class="line"></span><br><span class="line">	majority <span class="type">int</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//used as timer to start new election updated when</span></span><br><span class="line">	<span class="comment">//1. receiving AppendEntries RPC from current leader</span></span><br><span class="line">	<span class="comment">//2. granting vote to candidate</span></span><br><span class="line">	<span class="comment">//3. converting to candidate</span></span><br><span class="line">	lastTimeStamp time.Time</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Volatile state on candidate</span></span><br><span class="line">	votedPeer []<span class="type">bool</span></span><br><span class="line">	voteNum   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Lab-3A-Leader-Election"><a href="#Lab-3A-Leader-Election" class="headerlink" title="Lab 3A Leader Election"></a>Lab 3A Leader Election</h2><p>实现Election和Heartbeat机制，保证选举能成功并且leader出现问题之后会有后续的选举继续进行。</p>
<p>分为几个部分进行实现：</p>
<ol>
<li>timer机制</li>
<li>RequestVote RPC</li>
<li>Heartbeat</li>
</ol>
<h3 id="timer机制"><a href="#timer机制" class="headerlink" title="timer机制"></a>timer机制</h3><p>每一个peer都有一个timer，timer的每次重置时间大小是在一段随机的区间之内（在这个timeout &gt;&gt; RPC传递的时间时，基本能保证不会出现选举一直冲突无法选出Leader的情况）。如果自身处在Follower或者Candidate的状态，在timer触发后，peer会进行新一轮的选举，将自身的Term增加并给自己投票之后，像所有的其他peer发送RequestVote请求。其他的peer判断该请求是否合理，决定是否将票投给他。</p>
<ul>
<li>根据实验指导的建议采用 time.Sleep() 以及时间戳的形式来实现timer，每次重置定时器都记录下当前时间到lastTimeStamp。在循环中每间隔一段时间，判断当前时间与上次更新的差值是否大于了一定间隔。超过则开始新一轮选举</li>
<li>要注意Figure2中提到的重置定时器的时间点：”If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate”<ul>
<li>重新开始选举时</li>
<li>投票之后 （并不是处理RequestVote之后）</li>
<li>收到当前的Leader所发送的AppenEntries请求 （要注意Term）</li>
</ul>
</li>
</ul>
<h3 id="RequestVote-RPC"><a href="#RequestVote-RPC" class="headerlink" title="RequestVote RPC"></a>RequestVote RPC</h3><p>RPC的实现分为三个部分，发送RPC之前的数据准备，RPC handler，以及收到RPC回复后的处理。</p>
<h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><ul>
<li><p>发起新一轮选举之后，peer转换为Candidate并将相关的state都初始化，其中由于网络以及实现细节的原因可能会收到重复的投票，在Figure2的基础之上添加了一个map来记录已经给当前Candidate投过票的peer。</p>
</li>
<li><p>发送RPC要建立单独的线程并行发送，将需要的数据以参数的形式传递到线程中，避免在发送线程中读取（这样可能会造成发送给不同peer的线程中间插入了其他运行的线程，导致读取到的数据不是我们想要发送的）</p>
<p><code>go func(server int, term int, cid int, lastlogindex int, lastlogterm int)</code></p>
</li>
<li><p>还要注意同步的问题，在线程等待或者阻塞（比如time.Sleep(), channel在阻塞时等）的时候需要Unlock，如果不解锁除了会浪费并发的运行时间，还可能会造成deadlock，在踩坑中会提到。</p>
</li>
</ul>
<h4 id="RPC-Handler"><a href="#RPC-Handler" class="headerlink" title="RPC Handler"></a>RPC Handler</h4><ul>
<li>之后所有RPC handler和RPC回复都需要优先处理Term的问题，Term &lt;  currentTerm代表已经过时直接忽略，Term &gt; currentTerm说明自己落后了，将自己转化为Follower并重置相关状态。之后再进行后续的处理。</li>
<li>如果还没有投过票或者votedFor是当前的request中的CandidateId（可能由于网络问题），进行判断Candidate的log是否更加地up to date，看candiate的最后一个log的term是否比较大，如果相同index是否比较大（此处是 2B的内容），以此来保证最后所选出的Leader包含了所有commited entries。如果都满足要求则将票投给Candidate。</li>
</ul>
<h4 id="RPC回复处理"><a href="#RPC回复处理" class="headerlink" title="RPC回复处理"></a>RPC回复处理</h4><ul>
<li>处理Term</li>
<li>如果获得投票，则更新当前的投票数，获得的投票数大于majority时，peer将转化为Leader</li>
</ul>
<h3 id="Heartbeat"><a href="#Heartbeat" class="headerlink" title="Heartbeat"></a>Heartbeat</h3><p>每隔一段时间Leader需要给peer发送AppendEntries RPC请求来确保他的authority，保证其他的peer不会发起新的Election。</p>
<p>本质上Heartbeat message和其他的AppendEntries请求没有区别，并不全是携带的完全空的log，所以不需要将其特殊处理。</p>
<p>这里需要实现两部分。完成AppendEntries RPC，建立一个thread使得Leader不间断地发送AppendEntries。放到后面 3B 一起介绍。</p>
<h2 id="Lab-3B-Log"><a href="#Lab-3B-Log" class="headerlink" title="Lab 3B Log"></a>Lab 3B Log</h2><p>需要实现Log Replication。Client通过Start()函数传递command，Leader将command添加到log中后将其复制到所有其他的peer上。主要分为 Start函数，Heartbeat，AppendEntries RPC，以及commited and apply。重点是RPC中log的相关处理。</p>
<p>注意Log Index 是从1开始计算的，在进行数组访问的时候需要多加小心。</p>
<h3 id="Heartbeat和Start"><a href="#Heartbeat和Start" class="headerlink" title="Heartbeat和Start"></a>Heartbeat和Start</h3><p>Leader每间隔一段时间就发起复制，尝试将自身的log同步到其他的peer上。注意实验指导中提到发送的频率不能超过10次每秒。</p>
<p>Start中，如果是Leader，将command添加到log中，发起RPC，然后将Term，index等相关数据返回。</p>
<h3 id="AppendEntries-RPC"><a href="#AppendEntries-RPC" class="headerlink" title="AppendEntries RPC"></a>AppendEntries RPC</h3><h4 id="数据准备-1"><a href="#数据准备-1" class="headerlink" title="数据准备"></a>数据准备</h4><p>为了保证一致性，follower需要在和Leader发送的前一个log匹配上的情况下，才将Leader发送的entries添加到自己的log之中。</p>
<p>Leader根据两个数组来进行处理，nextIndex和matchIndex。nextIndex表示将要发送的entries的起点。将RPC的参数prevLogIndex和preLogTerm设置为nextIndex[peer]前面一格的内容。要发送的内容entries则从当前的log中截取nextIndex[peer]一直到末尾。</p>
<p>注意edge case，preLogIndex 为0的情况下，需要将prevLogTerm直接设为0，这种情况下需要handler直接处理为匹配上了。Leader将自己的所有log准备传送。</p>
<h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><ul>
<li><p>处理Term</p>
</li>
<li><p>检查prevLogIndex 和 prevLogTerm 是否匹配上，没有匹配上直接返回false</p>
</li>
<li><p>匹配上之后，将传递的entries一一对照，如果出现不同的Term，从冲突的index开始将之后log的清除掉，将RPC中剩余的entries添加上去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check whether there are conflict entries and insert new ones</span></span><br><span class="line"><span class="comment">// 这里的index变成了直接能查log的真实的下标，已经减1了	</span></span><br><span class="line">toMatchIndex := args.PrevLogIndex</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(args.Entries); i++ &#123;</span><br><span class="line">	<span class="keyword">if</span> toMatchIndex+i &gt;= <span class="built_in">len</span>(rf.log) || rf.log[toMatchIndex+i].Term != args.Entries[i].Term &#123;</span><br><span class="line">		temp := rf.log[:toMatchIndex+i]</span><br><span class="line">		temp = <span class="built_in">append</span>(temp, args.Entries[i:]...)</span><br><span class="line">		rf.log = temp</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
</li>
<li><p>如果LeaderCommit &gt; commitIndex，将commitIndex进行更新，调用applyMessage</p>
</li>
</ul>
<h4 id="RPC回复处理-1"><a href="#RPC回复处理-1" class="headerlink" title="RPC回复处理"></a>RPC回复处理</h4><ul>
<li>处理Term</li>
<li>成功时，根据prevLogIndex和entries的长度来更新matchIndex和nextIndex（matchIndex 是单调递增的，需要先判断防止过时的成功RPC将matchIndex回退了）。更新commitIndex， 如果大多数peer的matchIndex都超过了数字N并且这个index对应的term是当前的term（<strong>leader的crush有可能造成非当前term的log entry虽然已经在大多数机器上，仍然有可能被覆盖，见论文的Figure8</strong>），则将其更新为新的commitIndex。随后调用applyMessage进行apply</li>
<li>失败时将nextIndex进行回退，尝试匹配更早的log</li>
</ul>
<h3 id="Apply"><a href="#Apply" class="headerlink" title="Apply"></a>Apply</h3><p>每个可能造成commitIndex更新的部分之后调用applyMessage，将lastApplied到commitIndex之间的log按顺序进行apply。此处要避免lock出现的问题，在channel阻塞时要将lock放开。踩坑中也会提到。</p>
<p>这里为了保证同一时间只有一个thread在执行apply的任务，避免出现applyMsg传送的顺序出现混乱，添加了applyActive作为状态。</p>
<h2 id="Lab-3C-Persist"><a href="#Lab-3C-Persist" class="headerlink" title="Lab 3C Persist"></a>Lab 3C Persist</h2><p>将需要持久化的状态进行持久化，来从crush中进行恢复。需要持久化的状态在Figure2中提及：currentTerm, votedFor, log。</p>
<p>只需要在这几个状态有所变化之后，调用persist() 函数。同时在Make中初始化时，调用readPersist()，将数据读取出来。</p>
<h3 id="Back-Up-Index-Optimization"><a href="#Back-Up-Index-Optimization" class="headerlink" title="Back Up Index Optimization"></a>Back Up Index Optimization</h3><p>这里提到需要做一个index回退的优化，在AppendEntries RPC的replyArgs中添加XTerm，XIndex表示冲突的term和index</p>
<p>XTerm &#x3D; 0 时表示 prevLogIndex超出了log的范围，不为0则表示冲突的Term</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">reply.XIndex = rf.getLastLogIndex() + <span class="number">1</span></span><br><span class="line">reply.XTerm = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//prevLogIndex out of bounds</span></span><br><span class="line"><span class="keyword">if</span> args.PrevLogIndex &gt; rf.getLastLogIndex() &#123;</span><br><span class="line">	reply.Success = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> args.PrevLogIndex != <span class="number">0</span> &amp;&amp; args.PrevLogTerm != rf.log[args.PrevLogIndex<span class="number">-1</span>].Term &#123;</span><br><span class="line">	reply.XTerm = rf.log[args.PrevLogIndex<span class="number">-1</span>].Term</span><br><span class="line">	reply.Success = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">for</span> i := args.PrevLogIndex; i &gt;= <span class="number">1</span> &amp;&amp; rf.log[i<span class="number">-1</span>].Term == reply.XTerm; i-- &#123;</span><br><span class="line">		reply.XIndex = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在回复处理false情况时</p>
<ul>
<li>XTerm &#x3D; 0 说明超过follower的log范围，此时XIndex为默认值的log末尾的下一位</li>
<li>不等于0时，若自身含有对应的term，则将nextIndex设为term末尾的下一位，若不含有，则设为XIndex，表示跳过了follower中所有这个term的log entry</li>
<li>注意这里面的索引的转换，log的index是从1开始的，会比较绕</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//optimization : back up in term instead of index</span></span><br><span class="line"><span class="keyword">var</span> next <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> reply.XTerm == <span class="number">0</span> &#123;</span><br><span class="line">	next = reply.XIndex</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> i = <span class="built_in">len</span>(rf.log) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">if</span> rf.log[i].Term == reply.XTerm &#123;</span><br><span class="line">			next = i + <span class="number">2</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">		next = reply.XIndex</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">rf.nextIndex[server] = next</span><br></pre></td></tr></table></figure>

<h2 id="Lab-3D-Snapshot"><a href="#Lab-3D-Snapshot" class="headerlink" title="Lab 3D Snapshot"></a>Lab 3D Snapshot</h2><p>如果log不进行压缩，随着时间的推移造成log的累计，会导致每次重启所需要的时间越来越长。采用Snapshot的log compaction方法。在这个实验中，对每个peer分别进行snapshot，保存某个已经applied的log index的整体数据，然后将所有之前的log都抛弃。</p>
<h3 id="改变Index"><a href="#改变Index" class="headerlink" title="改变Index"></a>改变Index</h3><p>snapshot由于将之前的log entries全都舍弃，在本地的index索引方式会发生变化。某个index的值为i，则其对应访问本地数组log[]的索引应该是i - lastIncludedIndex - 1。这里lastIncludedIndex表示的是snapshot包含的最后一个log entry的索引。</p>
<p>这里比较繁琐，索引本身是从1开始的，加上之前实现了index回退的优化，逻辑会比较绕，需要把每个利用到索引的地方都修改一下。</p>
<h3 id="Snapshot函数"><a href="#Snapshot函数" class="headerlink" title="Snapshot函数"></a>Snapshot函数</h3><p>根据参数更新lastIncludedIndex和lastIncludedTerm，截断前面的log。</p>
<h3 id="InstallSnapshot-RPC"><a href="#InstallSnapshot-RPC" class="headerlink" title="InstallSnapshot RPC"></a>InstallSnapshot RPC</h3><p>有时候Follower落后太多，当nextIndex &lt;&#x3D; lastIncluededIndex，即是要发送的log已经被snapshot抛弃时，Leader需要将自己的Snapshot复制到Follower上，调用InstallSnapshot RPC。</p>
<h4 id="Handler-1"><a href="#Handler-1" class="headerlink" title="Handler"></a>Handler</h4><ul>
<li><p>处理Term</p>
</li>
<li><p>实验指导中提到只能将Follower的状态推进不能回退，当Leader发送的snapshot最后index比Follower的lastIncludedIndex或者是appliedIndex更小时，如果更新snapshot会导致状态回退，所以直接返回不进行处理</p>
</li>
<li><p>处理log，根据参数匹配Follower中的log，如果有冲突部分，则从冲突部分开始之后的log entries全部删除，没有冲突则保留log</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">toMatchIndex := args.LastIncludedIndex - rf.lastIncludedIndex - <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> toMatchIndex &lt; <span class="built_in">len</span>(rf.log) &amp;&amp; rf.log[toMatchIndex].Term == args.LastIncludedTerm &#123;</span><br><span class="line">	rf.log = rf.log[toMatchIndex+<span class="number">1</span>:]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	rf.log = rf.log[:<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后更新本地的snapshot相关状态，将snapshot apply，apply的部分后面踩坑会提到。</p>
</li>
</ul>
<h3 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h3><ul>
<li>AppendEntries handler在处理时，如果preLogIndex在lastInlcudedIndex之前，也即是发来的args.Entries中有一部分落在了snapshot之中，需要截去这一部分，然后剩余的部分照旧执行。这里注意不能够因为落在了snapshot之中就直接返回true，发送来的args.Entries中与可能存在冲突，也可能有更新。</li>
<li>实现Backup Index的优化之后加上snapshot并没有太大的变化，如果返回的Term在log中不存在，XIndex落在了Leader的snapshot范围之内，下一次AppendEntries准备的时候就会自动变成InstallSnapshot。</li>
<li>初始化的时候lastApplied和commitedIndex要根据snapshot进行调整不再是0了。</li>
</ul>
<h1 id="Reflection-踩坑以及注意"><a href="#Reflection-踩坑以及注意" class="headerlink" title="Reflection 踩坑以及注意"></a>Reflection 踩坑以及注意</h1><ul>
<li><p>由于阻塞等原因Unlock之后再Lock时要注意检查此时的状态有没有发生改变，并发中可能已经处理了很多别的线程了。</p>
</li>
<li><p>Dprintf很好用，在一开始写代码的时候就注意加上debug信息可以有效减轻debug的负担。写了一大段再回头去加有时候会很痛苦</p>
</li>
<li><p>注意RPC失败和返回False的不同处理，有的RPC可以不做区分，但由于RPC失败时reply会是默认值false，对于AppendEntries，返回false意味着没有匹配成功需要进行后续处理，必须要区分。</p>
</li>
<li><p>Lab2B跑出的bug</p>
<p>出错的代码</p>
<pre><code><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries []LogEntry</span><br><span class="line">prevLogIndex := <span class="number">0</span></span><br><span class="line">prevLogTerm := <span class="number">0</span></span><br><span class="line"> <span class="comment">// if rf.getLastLogIndex() &gt;= rf.nextIndex[i] &#123;</span></span><br><span class="line">        <span class="comment">//  prevLogIndex = rf.nextIndex[i] - 1</span></span><br><span class="line">        <span class="comment">//  if prevLogIndex != 0 &#123;</span></span><br><span class="line">        <span class="comment">//      prevLogTerm = rf.log[prevLogIndex-1].Term</span></span><br><span class="line">        <span class="comment">//  &#125;</span></span><br><span class="line">        <span class="comment">//  entries = rf.log[rf.nextIndex[i]-1:]</span></span><br><span class="line">  <span class="comment">// &#125;     </span></span><br></pre></td></tr></table></figure>
</code></pre>
<p>由于根据论文的figure2设置了rf.getLastLogIndex() &gt;&#x3D; rf.nextIndex[i] 的判断条件，刚初始化的时候nextIndex[I] 的值为lastLogIndex + 1，这个条件是一定不成立的，导致发出的RPC都是空的初始值。这里就要注意到，这样设置默认的index和term都为0，entry是空，handler会认为已经匹配上了log的内容，会根据leader的commitIndex更新自己的Index，如果log里有这个receiver自己作为leader时收到的还没有commit的log，会被错误的commit导致出现错误。所以即使是空的entry，也要设置相应的prevLogIndex和term，将判断条件取消后就通过测试了</p>
</li>
<li><p>applyMessage这块的函数主要涉及到两个问题</p>
<ul>
<li>Snapshot Debug出现的问题，applied message 到10条后线程被阻塞， 最后发现test每10条调用一次snapshot，但同时applied的channel还在阻塞状态。在发送applyMsg时没有Unlock()，导致发生了死锁。但是在释放Lock之后要注意到，由于applyMessage这个方法会被反复调用，很有可能会出现多个applyMessage并发，导致发送的msg的顺序出现错乱（释放lock之后就被其他线程占用了，还没有将消息放进channel，这时候另一个applyMessage运行可能会将之后index的log先提交上去）。在这里采用设置applyActiveflag的方法，保证同一时间只有一个appleMessage的进程。</li>
<li>添加snapshot之后涉及到applyCh需要传送snapshot和一般的update，放到同一个函数中来实现，同时优先更新snapshot。如果不优先snapshot，可能造成状态的回退（InstallSnapshot不会回退状态，在新snapshot超过当前的snapshot和lastAppliedIndex的情况下才会继续。在apply的过程中，如果snapshot的msg还没有送到channel的时候，将超过lastIncludedIndex的部分apply上去了，在snapshot被apply之后会造成状态的回退。）所以设置applySnapshot的flag，优先进行Snapshot的处理。</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> applyMessage() &#123;</span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// <span class="doctag">BUG:</span>没有在channel阻塞的时候释放mutex</span></span><br><span class="line">	<span class="comment">// for i := rf.lastApplied + 1; i &lt;= rf.commitIndex; i++ &#123;</span></span><br><span class="line">	<span class="comment">// 	DPrintf(&quot;apply : peer %v apply command at index %v&quot;, rf.me, i)</span></span><br><span class="line">	<span class="comment">// 	go func(command interface&#123;&#125;, commandIndex int) &#123;</span></span><br><span class="line">	<span class="comment">// 		rf.applyCh &lt;- ApplyMsg&#123;CommandValid: true, Command: command, CommandIndex: commandIndex&#125;</span></span><br><span class="line">	<span class="comment">// 	&#125;(rf.log[i-rf.lastIncludedIndex-1].Command, i)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 	rf.lastApplied++</span></span><br><span class="line">	<span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> rf.applyActive == <span class="literal">false</span> &#123;</span><br><span class="line">		rf.applyActive = <span class="literal">true</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> rf.applySnapshot == <span class="literal">true</span> || rf.lastApplied &lt; rf.commitIndex &#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> rf.applySnapshot &#123;</span><br><span class="line">			applyMsg := ApplyMsg&#123;SnapshotValid: <span class="literal">true</span>, Snapshot: rf.snapshot, SnapshotTerm: rf.lastIncludedTerm, SnapshotIndex: rf.lastIncludedIndex&#125;</span><br><span class="line">			rf.lastApplied = rf.lastIncludedIndex</span><br><span class="line">			rf.applySnapshot = <span class="literal">false</span></span><br><span class="line">			rf.mu.Unlock()</span><br><span class="line">			rf.applyCh &lt;- applyMsg</span><br><span class="line">			rf.mu.Lock()</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			commandIndex := rf.lastApplied + <span class="number">1</span></span><br><span class="line">			command := rf.log[commandIndex-rf.lastIncludedIndex<span class="number">-1</span>].Command</span><br><span class="line">			<span class="comment">//DPrintf(&quot;apply : peer %v apply command at index %v, logs : %v&quot;, rf.me, commandIndex, rf.log)</span></span><br><span class="line">			DPrintf(<span class="string">&quot;apply : peer %v apply command at index %v&quot;</span>, rf.me, commandIndex)</span><br><span class="line"></span><br><span class="line">			rf.lastApplied++</span><br><span class="line">			rf.mu.Unlock()</span><br><span class="line">			rf.applyCh &lt;- ApplyMsg&#123;CommandValid: <span class="literal">true</span>, Command: command, CommandIndex: commandIndex&#125;</span><br><span class="line">			rf.mu.Lock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.applyActive = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>最后整体test的时候会超时，之前3B的测试其实也超过实验指导里的时间了当时没注意。CPU运行的时间和guide中看起来差不多，主要是waiting和sleeping的时间有点长。发现是因为我之前把heartbeat的频率设置的太慢了，每150ms发送一次，实验中提到最快其实可以设置到100ms一次。增大频率之后可以通过测试了。</p>
</li>
<li><p>有一个de了很久的bug发现是因为把赋值的顺序给搞错了。Snapshot函数时没有注意变量赋值的顺序，先把lastIncludedIdnex改掉了，拿着已经转换的lastIncludedIndex去截log<code>rf.log = rf.log[index-rf.lastIncludedIndex:]</code>，导致log完全保留了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Snapshot(index <span class="type">int</span>, snapshot []<span class="type">byte</span>) &#123;</span><br><span class="line">	<span class="comment">// Your code here (3D).</span></span><br><span class="line">	rf.mu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	DPrintf(<span class="string">&quot;snapshot : peer %v start snapshot at index %v, lastIncludedIndex is %v, lastLogIndex is %v&quot;</span>, rf.me, index, rf.lastIncludedIndex, rf.getLastLogIndex())</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> index &lt;= rf.lastIncludedIndex || index &gt; rf.getLastLogIndex() &#123;</span><br><span class="line">		log.Panic(<span class="string">&quot;snapshot : can&#x27;t create snapshot index not valid&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rf.lastIncludedTerm = rf.log[index-rf.lastIncludedIndex<span class="number">-1</span>].Term</span><br><span class="line">	rf.log = rf.log[index-rf.lastIncludedIndex:]</span><br><span class="line">	rf.lastIncludedIndex = index</span><br><span class="line">	rf.snapshot = snapshot</span><br><span class="line">	rf.persist()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多线程Debug真的很头疼，一定要在开始写代码的时候就加好调试信息，然后根据信息慢慢地去推论什么地方可能出错了。Debug到最后发现是个低级错误的时候多少是有点崩溃的，要保证良好的心态不能急。写的时候也要注意细节，多思考几遍，写完也再回头看看，尽量地做到bug free。同时写完能测试的时候抓紧测试，确保当前写的代码是正确的。如果一口气写好几个块出bug了回头来de会很想死。</p>
</li>
<li><p>写下来的感觉挺累的，一方面在细节方面纠结，生怕写错了最后不好debug（尤其是这个Index从1开始，每次写index相关的都很紧张，多check两遍有没有搞错），导致每一段代码都写的比较慢。另一方面debug的时候要从繁杂的调试信息中间去抽丝剥茧，一时半会儿是真找不出来，会很有挫败感。写完感觉让我对并发有了更深的理解。</p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/06/17/first-blog/" rel="prev" title="first blog">
      <i class="fa fa-chevron-left"></i> first blog
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Theory"><span class="nav-number">2.</span> <span class="nav-text">Theory</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Leader-Election"><span class="nav-number">2.1.</span> <span class="nav-text">Leader Election</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Log-Replication"><span class="nav-number">2.2.</span> <span class="nav-text">Log Replication</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Safety"><span class="nav-number">2.3.</span> <span class="nav-text">Safety</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Implementation"><span class="nav-number">3.</span> <span class="nav-text">Implementation</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-3A-Leader-Election"><span class="nav-number">3.1.</span> <span class="nav-text">Lab 3A Leader Election</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#timer%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.1.</span> <span class="nav-text">timer机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RequestVote-RPC"><span class="nav-number">3.1.2.</span> <span class="nav-text">RequestVote RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">数据准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC-Handler"><span class="nav-number">3.1.2.2.</span> <span class="nav-text">RPC Handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC%E5%9B%9E%E5%A4%8D%E5%A4%84%E7%90%86"><span class="nav-number">3.1.2.3.</span> <span class="nav-text">RPC回复处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Heartbeat"><span class="nav-number">3.1.3.</span> <span class="nav-text">Heartbeat</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-3B-Log"><span class="nav-number">3.2.</span> <span class="nav-text">Lab 3B Log</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Heartbeat%E5%92%8CStart"><span class="nav-number">3.2.1.</span> <span class="nav-text">Heartbeat和Start</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AppendEntries-RPC"><span class="nav-number">3.2.2.</span> <span class="nav-text">AppendEntries RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87-1"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">数据准备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Handler"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">Handler</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC%E5%9B%9E%E5%A4%8D%E5%A4%84%E7%90%86-1"><span class="nav-number">3.2.2.3.</span> <span class="nav-text">RPC回复处理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Apply"><span class="nav-number">3.2.3.</span> <span class="nav-text">Apply</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-3C-Persist"><span class="nav-number">3.3.</span> <span class="nav-text">Lab 3C Persist</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Back-Up-Index-Optimization"><span class="nav-number">3.3.1.</span> <span class="nav-text">Back Up Index Optimization</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lab-3D-Snapshot"><span class="nav-number">3.4.</span> <span class="nav-text">Lab 3D Snapshot</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%94%B9%E5%8F%98Index"><span class="nav-number">3.4.1.</span> <span class="nav-text">改变Index</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Snapshot%E5%87%BD%E6%95%B0"><span class="nav-number">3.4.2.</span> <span class="nav-text">Snapshot函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InstallSnapshot-RPC"><span class="nav-number">3.4.3.</span> <span class="nav-text">InstallSnapshot RPC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Handler-1"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">Handler</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="nav-number">3.4.4.</span> <span class="nav-text">需要注意的地方</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reflection-%E8%B8%A9%E5%9D%91%E4%BB%A5%E5%8F%8A%E6%B3%A8%E6%84%8F"><span class="nav-number">4.</span> <span class="nav-text">Reflection 踩坑以及注意</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Lancey</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Lancey</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
